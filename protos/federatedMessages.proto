syntax = "proto3";

package federatedMessages;

/* To initialize the model weights on the server that generates the federated average
 * It will have a repeated field for the set of gradient weights received from each 
 * client. "Packed" is set to true to get a more efficient encoding */
message ModelServer {
  repeated ClientTensor gradients = 1 [packed = true];
} 

message MessageTensor {
  required string gradientName = 1; // Name of the gradient that is being transmitted, e.g. "doc-topics distribution"
  required bytes gradient = 2;      // Tensor containing the gradient update
}

message MessageAdditionalData {
  required bool federation_completed = 1;  // True when the number maximum of iterations has been reached and the server's response has reached the client
  required bool iteration_completed = 2;   // True when the current iteration's aggregated tensor of gradients has arrived at the client
  required uint32 current_iteration = 3;   // Iteration to which the current message data corresponds
  required uint32 num_max_iterations = 4;  // Maximum number of iterations that the federation has
}

enum MessageType {
  CLIENT_TENSOR_SEND = 1;
  CLIENT_CONFIRM_RECEIVED = 2;
  SERVER_AGGREGATED_TENSOR_SEND = 3;
  SERVER_CONFIRM_RECEIVED = 4; 
}

message MessageHeader {
  optional uint64 id_request = 1;
  optional uint64 id_response = 2;
  optional uint64 id_to_request = 3;
  required MessageType message_type = 4;
}

message ClientTensorRequest {
  required MessageHeader header = 1;
  required MessageAdditionalData metadata = 2;
  required MessageTensor data = 3;
}

message ServerAggregatedTensorRequest {
  required MessageHeader header = 1;
  required MessageAdditionalData metadata = 2;
  required MessageTensor data = 3;
}

message ClientReceivedResponse {
  required MessageHeader header = 1;
  required MessageAdditionalData metadata = 2;
}

message ServerReceivedResponse {
  required MessageHeader header = 1;
  required MessageAdditionalData metadata = 2;
}

