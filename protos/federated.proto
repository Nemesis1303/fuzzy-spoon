syntax = "proto3";

package federated;

/* To initialize the model weights on the server that generates the federated average
 * It will have a repeated field for the set of gradient weights received from each 
 * client. "Packed" is set to true to get a more efficient encoding */
message ModelServer {
  repeated Update gradients = 1;
} 

message Update {
  string gradientName = 1; // Name of the gradient that is being transmitted, e.g. "doc-topics distribution"
  bytes gradient = 2;      // Tensor containing the gradient update
}

message MessageAdditionalData {
  bool federation_completed = 1;  // True when the number maximum of iterations has been reached and the server's response has reached the client
  bool iteration_completed = 2;   // True when the current iteration's aggregated tensor of gradients has arrived at the client
  uint32 current_iteration = 3;   // Iteration to which the current message data corresponds
  uint32 num_max_iterations = 4;  // Maximum number of iterations that the federation has
}

enum MessageType {
  CLIENT_TENSOR_SEND = 0;
  CLIENT_CONFIRM_RECEIVED = 1;
  SERVER_AGGREGATED_TENSOR_SEND = 2;
  SERVER_CONFIRM_RECEIVED = 3; 
}

message MessageHeader {
  optional string id_request = 1;
  optional string id_response = 2;
  optional string id_to_request = 3;
  MessageType message_type = 4;
}

message ClientTensorRequest {
  MessageHeader header = 1;
  MessageAdditionalData metadata = 2;
  Update data = 3;
}

message ServerAggregatedTensorRequest {
  MessageHeader header = 1;
  MessageAdditionalData metadata = 2;
  Update data = 3;
}

message ClientReceivedResponse {
  MessageHeader header = 1;
  MessageAdditionalData metadata = 2;
}

message ServerReceivedResponse {
  MessageHeader header = 1;
  MessageAdditionalData metadata = 2;
}

service Federation {
  rpc sendLocalTensor(ClientTensorRequest) returns (ServerReceivedResponse) {}
  rpc sendAggregatedTensor(ServerAggregatedTensorRequest) returns (ClientReceivedResponse) {}
}